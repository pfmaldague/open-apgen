#if HAVE_CONFIG_H
#include <config.h>
#endif
#ifdef GUI
/*
 * MODULE: BxConvert.c
 * AUTHOR: Automatically generated by Builder Xcessory
 * 
 * Description: This module contains various utilities, converters 
 *	for XmStrings (to work properly with app-defaults), and if needed
 *	the XPM pixmap utilities.
 *	
 * Edit the file ${BX}/gen/bxutils.c (BX$SYSTEM:[gen]bxutils.c on VMS) to
 * make system wide changes to this file which will be visible next time
 * this file is generated. 
 * ${BX} is the directory where Builder Xcessory is installed.
 */

/*
 * BX supplies a string format for compound strings:
 *
 *		::[#tag][:t][:r]["str"]
 *
 * where:
 *	:: = indicates compound string.
 *	tag =  the font tag
 *	:t = separator (if not seen no separator added to segment)
 *	:r = right to left (if not seen left to right assumed)
 *	"str" = the text of the string.
 *
 * The components for the compound string can be repeated any number of
 * times.
 */

/*****************************************************************************
 *       INCLUDE FILES
 *****************************************************************************/

#ifdef _WIN32
extern "C" {
#endif
#include <Xm/Xm.h>
#ifdef _WIN32
}
#endif

#include <Xm/RowColumn.h>
#include <stdio.h>
#include <ctype.h>

/*
 * Include stdlib.h and malloc.h if code is C++, ANSI, or Extended ANSI.
 */
#if defined(__cplusplus) || defined(__STDC__) || defined(__EXTENSIONS__)
#include <stdlib.h>
#ifndef VMS
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
#endif
#endif

/*****************************************************************************
 *       TYPDEFS AND DEFINES
 *****************************************************************************/

/*
 * Undefine this if you want to use native strcasecmp.
 */
#define LOCAL_STRCASECMP

#ifdef _NO_PROTO
#ifdef NeedFunctionPrototypes
#undef NeedFunctionPrototypes
#endif
#endif

/*
 * Define SUPPORTS_WCHARS if the system supports wide character sets
 */
#if !defined(VAX) && !defined(__CENTERLINE__)
#define SUPPORTS_WCHARS
#endif

/*
 * Handy definition used in SET_BACKGROUND_COLOR
*/
#define UNSET		(-1)

/*
 * Set state of inclusion of prototypes properly
 */
#ifdef NeedFunctionPrototypes
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#else
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#endif

#ifdef NeedFunctionPrototypes
#ifdef __cplusplus
#define UARG(a, b)	a,
#define GRAU(a, b)	a)
#else
#define UARG(a, b)	a b,
#define GRAU(a, b)	a b)
#endif
#else
#define UARG(a, b)	a b;
#define GRAU(a, b)	a b;
#endif

/*
 * Set up strcasecmp function
 */
#if defined(LOCAL_STRCASECMP)
#define STRCASECMP	StrCasecmp
#ifndef NeedFunctionPrototypes
static int StrCasecmp();
#else
static int StrCasecmp(const char*, const char*);
#endif
#else
#define STRCASECMP	strcasecmp
#endif

/*
 * Define XTPOINTER so it works with all releases of
 * Xt and c++.
 */
#ifdef __cplusplus
#if XtSpecificationRelease < 5
#define XTPOINTER	char *
#else
#define XTPOINTER	XPointer
#endif
#else
#define XTPOINTER	XtPointer
#endif

/*
 * The following enum is used to support wide character sets.
 * Use this enum for references into the Common Wide Characters array.
 * If you add to the array, ALWAYS keep NUM_COMMON_WCHARS as the last
 * entry in the enum.  This will maintain correct memory usage, etc.
 */
enum { WNull, WTab, WNewLine, WCarriageReturn, WFormFeed, WVerticalTab,
       WBackSlash, WQuote, WHash, WColon, WideF, WideL, WideN, WideR,
       WideT, WideV, WideUF, WideUL, WideUR, WideUT, WideZero, WideOne,
       NUM_COMMON_WCHARS };

/*****************************************************************************
 *       GLOBAL DECLARATIONS
 *****************************************************************************/

/*****************************************************************************
 *       EXTERNAL DECLARATIONS
 *****************************************************************************/

/*****************************************************************************
 *	STATIC DECLARATION
 *****************************************************************************/

#ifndef NeedFunctionPrototypes

#ifndef SUPPORTS_WCHARS
static int	 mblen			();
#endif
static int	strlenWc		();
static size_t	doMbstowcs		();
static size_t	doWcstombs 		();
static void	copyWcsToMbs		();
static int 	dombtowc		();
static Boolean	extractSegment		();
static XmString	StringToXmString	();
static char*	getNextCStrDelim	();
static int	getCStrCount		();
static wchar_t *CStrCommonWideCharsGet	();

#else

#ifndef SUPPORTS_WCHARS
static int 	mblen			(char*, size_t);
#endif
static int	strlenWc		(wchar_t*);
static size_t	doMbstowcs		(wchar_t*, char*, size_t);
static size_t	doWcstombs 		(char*, wchar_t*, size_t);
static void	copyWcsToMbs		(char*, wchar_t*, int, Boolean);
static int 	dombtowc		(wchar_t*, char*, size_t);
static Boolean	extractSegment		(wchar_t**, wchar_t**, int *,
					 wchar_t**, int*, int*,	Boolean*);
static XmString	StringToXmString	(char*);
static char*	getNextCStrDelim	(char*);
static int	getCStrCount		(char*);
static wchar_t *CStrCommonWideCharsGet	();

#endif

/*****************************************************************************
 *	STATIC CODE
 *****************************************************************************/

#if defined(LOCAL_STRCASECMP) 

/*
 * Function:
 *      cmp = StrCasecmp(s1, s2);
 * Description:
 *      Compare two strings ignoring case
 * Input:
 *      s1 - char * : string 1 to compare
 *      s2 - char * : string 2 to compare
 * Output:
 *      int :  0; s1 == s2
 *             1; s1 != s2
 */
static int StrCasecmp
    ARGLIST((s1, s2))
        ARG(const char *, s1)
        GRA(const char *, s2)
{
    int        c1, c2;
    
    while (*s1 && *s2)
    {
        c1 = isupper(*s1) ? tolower(*s1) : *s1;
        c2 = isupper(*s2) ? tolower(*s2) : *s2;
        if (c1 != c2)
        {
            return(1);
        }
        s1++;
        s2++;
    }
    if (*s1 || *s2)
    {
        return(1);
    }
    return(0);
}
#endif

#ifndef SUPPORTS_WCHARS
/*
 * Function:
 *      len = mblen(s, n);
 * Description:
 *      The mblen function for platforms that don't have one. This
 * 	function simply returns a length of 1 since no wide character
 *	support exists for this platform.
 * Input:
 *      s - char * : the character string to get the length from
 *	n - size_t : the size of the string
 * Output:
 *      int : always 1
 */
static int mblen
    ARGLIST((s, n))
        ARG(char *, s)
        GRA(size_t, n)
{
    return(1);
}
#endif

/*
 * Function:
 *      len = strlenWc(ptr);
 * Description:
 *      Return the number of characters in a wide character string (not
 *	the characters in the resultant mbs).
 * Input:
 *      ptr - wchar_t* : pointer to the wcs to count
 * Output:
 *      int : the number of characters found
 */
static int strlenWc
    ARGLIST((ptr))
        GRA(wchar_t *,ptr)
{
    wchar_t	*p = ptr;
    int	x = 0;
    
    if (!ptr) return(0);
    
    while (*p++) x++;
    return (x);
}

/*
 * Function:
 *      bytesConv = doMbstowcs(wcs, mbs, n);
 * Description:
 *      Create a wcs string from an input mbs. 
 * Input:
 *	wcs - wchar_t* : pointer to result buffer of wcs
 *      mbs - char* : pointer to the source mbs
 *	n - size_t : the number of characters to convert
 * Output:
 *      bytesConv - size_t : number of bytes converted
 */
static size_t doMbstowcs
    ARGLIST((wcs, mbs, n))
        ARG(wchar_t *,wcs)
        ARG(char *, mbs)
        GRA(size_t, n)
{
#ifndef SUPPORTS_WCHARS
    int i;
    
    for (i = 0; i < n && mbs[i] != 0; ++i)
    {
	wcs[i] = mbs[i];
    }
    wcs[i++] = 0;
    return(i);
#else
    return(mbstowcs(wcs, mbs, n));
#endif
}

/*
 * Function:
 *      bytesConv = doWcstombs(wcs, mbs, n);
 * Description:
 *      Create a mbs string from an input wcs.
 * Input:
 *	wcs - wchar_t* : pointer to the source wcs
 *      mbs - char* : pointer to result mbs buffer 
 *	n - size_t : the number of characters to convert
 * Output:
 *      bytesConv - size_t : number of bytes converted
 */
static size_t doWcstombs
    ARGLIST((mbs, wcs, n))
        ARG(char *, mbs)
        ARG(wchar_t *, wcs)
        GRA(size_t, n)
{
#ifndef SUPPORTS_WCHARS
    int i;
    
    for (i = 0; i < n && wcs[i] != 0; ++i)
    {
	mbs[i] = wcs[i];
    }
    mbs[i] = 0;
    return(i);
#else
    return(wcstombs(mbs, wcs, n));
#endif
}

/*
 * Function:
 *      status = dombtowc(wide, multi, size);
 * Description:
 *      Convert a multibyte character to a wide character.
 * Input:
 *      wide	- wchar_t *	: where to put the wide character
 *	multi	- char *	: the multibyte character to convert
 *	size	- size_t	: the number of characters to convert
 * Output:
 *      0	- if multi is a NULL pointer or points to a NULL character
 *	#bytes	- number of bytes in the multibyte character
 *	-1	- multi is an invalid multibyte character.
 *
 *	NOTE:  if wide is NULL, then this returns the number of bytes in
 *	       the multibyte character.
 */
static int dombtowc
    ARGLIST((wide, multi, size))
        ARG(wchar_t *, wide)
        ARG(char *, multi)
        GRA(size_t, size)
{
    int		retVal = 0;
    
#ifndef SUPPORTS_WCHARS
    if ((multi == NULL) || (*multi == '\000'))
    {
	if (wide) wide[0] = '\0';
	return (0);
    }
    
    for (retVal = 0; retVal < size && multi[retVal] != '\000'; retVal++)
    {
	if (wide != NULL)
	{
	    wide[retVal] = multi[retVal];
	}
    }
#else
    retVal = mbtowc(wide, multi, size);
#endif
    return(retVal);
}

static void XmStringCvtDestroy
    ARGLIST((app, to, data, args, num_args))
        UARG(XtAppContext, app)
        ARG(XrmValue *, to)
        UARG(XtPointer, data)
        UARG(XrmValue *, args)
        GRAU(Cardinal *, num_args)
{
    XmStringFree(*(XmString*)(to->addr));
}

static void XmStringTableCvtDestroy
    ARGLIST((app, to, data, args, num_args))
        UARG(XtAppContext, app)
        ARG(XrmValue *, to)
        UARG(XtPointer, data)
        UARG(XrmValue *, args)
        GRAU(Cardinal *, num_args)
{
    XmString	*tblPtr = *(XmString**)(to->addr);

    while (*tblPtr)
    {
	XmStringFree(*tblPtr);
    }
    XtFree((char*)(*(XmString**)(to->addr)));
}    

/*****************************************************************************
 *	GLOBAL CODE
 *****************************************************************************/

/*
 * Function:
 *      CONVERT(w, from_string, to_type, to_size, success);
 * Description:
 *      A converter wrapper for convenience from BuilderXcessory.
 * Input:
 *      w - Widget : the widget to use for conversion
 *	from_string - char * : the string to convert from
 *	to_type - char * : the type to convert to
 *	to_size - int : the size of the conversion result
 *	success - Boolean* : Set to the result value of the conversion
 * Output:
 *      None
 */
#ifndef IGNORE_CONVERT
XtPointer CONVERT
    ARGLIST((w, from_string, to_type, to_size, success))
        ARG(Widget, w)
        ARG(const char *, from_string)
        ARG(const char *, to_type)
        ARG(int, to_size)
        GRA(char *, success)
{
    XrmValue		fromVal, toVal;	/* resource holders		*/
    Boolean		convResult;	/* return value			*/
    XtPointer		val;		/* Pointer size return value    */

    to_size = 0;

    /*
     * We will assume that the conversion is going to fail and change this
     * value later if the conversion is a success.
     */
    *success = False;

    /*
     * Since we are converting from a string to some type we need to
     * set the fromVal structure up with the string information that
     * the caller passed in.
     */
    fromVal.size = strlen(from_string) + 1;
    fromVal.addr = (char *) from_string;

    /*
     * Since we are not sure what type and size of data we are going to
     * get back we will set this up so that the converter will point us
     * at a block of valid data.
     */
    toVal.size = 0;
    toVal.addr = NULL;

    /*
     * Now lets try to convert this data by calling this handy-dandy Xt
     * routine.
     */
    convResult = XtConvertAndStore(w, XmRString, &fromVal, to_type, &toVal);
    

    /*
     * Now we have two conditions here.  One the conversion was a success
     * and two the conversion failed.
     */
    if(!convResult)
    {
	/*
	 * If this conversion failed that we can pretty much return right
	 * here because there is nothing else we can do.
	 */
	return((XtPointer) NULL);
    }

    /*
     * If we get this far that means we did the conversion and all is
     * well.  Now we have to handle the special cases for type and
     * size constraints.
     */
    if(!strcmp(to_type, "String"))
    {
	/*
	 * Since strings are handled different in Xt we have to deal with
	 * the conversion from a string to a string.  When this happens the
	 * toVal.size will hold the strlen of the string so generic
	 * conversion code can't handle it.  It is possible for a string to
	 * string conversion to happen so we do have to watch for it.
	 */
	val = (XTPOINTER)toVal.addr;
    }
    else
    {
	/*
	 * Here is the generic conversion return value handler.  This 
	 * just does some size specific casting so that value that we
	 * return is in the correct bytes of the XtPointer that we
	 * return.  Here we check all sizes from 1 to 8 bytes.
	 */
	switch(toVal.size)
	{
	case 1:
	    val = (XTPOINTER)((long)*(char*)toVal.addr);
	    break;
	case 2:
	    val = (XTPOINTER)((long)*(short*)toVal.addr);
	    break;
	case 4:
	    val = (XTPOINTER)((long)*(int*)toVal.addr);
	    break;
	case 8:
	default:
	    val = (XTPOINTER)((long)*(long*)toVal.addr);
	    break;
	}
    }

    /*
     * Well everything is done and the conversion was a success so lets
     * set the success flag to True.
     */
    *success = convResult;

    /*
     * Finally lets return the converted value.
     */
    /*SUPPRESS 80*/
    return(val);
}
#endif

/*
 * Function:
 *      MENU_POST(p, mw, ev, dispatch);
 * Description:
 *      A converter wrapper for convenience from BuilderXcessory.
 * Input:
 *      p - Widget : the widget to post
 *	mw - XtPointer : the menu widget
 *	ev - XEvent* : the event that caused the menu post
 *	dispatch - Boolean* : not used
 * Output:
 *      None
 */

#ifndef IGNORE_MENU_POST

void MENU_POST
    ARGLIST((p, mw, ev, dispatch))
        UARG(Widget, p)
        ARG(XtPointer, mw)
        ARG(XEvent *, ev)
        GRAU(Boolean *, dispatch)
{
    Arg	args[2];
    int	argcnt;
    int	button;
    Widget m = (Widget)mw;
    XButtonEvent *e = (XButtonEvent *)ev;

    argcnt = 0;
    XtSetArg(args[argcnt], XmNwhichButton, &button);
    argcnt++;
    XtGetValues(m, args, argcnt);
    if(e->button != button) return;
    XmMenuPosition(m, e);
    XtManageChild(m);
}
#endif

/*
 * Function:
 *	w = BxFindTopShell(start);
 * Description:
 *	Go up the hierarhcy until we find a shell widget.
 * Input:
 *      start - Widget : the widget to start with.
 * Output:
 *	w - Widget : the shell widget.
 */
#ifndef _BX_FIND_TOP_SHELL
#define _BX_FIND_TOP_SHELL

Widget BxFindTopShell
    ARGLIST((start))
        GRA(Widget, start)
{
    Widget	p;
    
    while((p = XtParent(start)))
    {
	start = p;
    }
    return(start);
}
#endif /* _BX_FIND_TOP_SHELL */

/*
 * Function:
 *	BxWidgetIdsFromNames(ref, cbName, stringList)
 * Description:
 *	Return an array of widget ids from a list of widget names.
 * Input:
 *	ref - Widget : reference widget.
 *	cbName - char* : callback name.
 *	stringList - char*: list of widget names.
 * Output:
 *	WidgetList : array of widget IDs.
 */

#ifndef _BX_WIDGETIDS_FROM_NAMES
#define _BX_WIDGETIDS_FROM_NAMES
#endif /* _BX_WIDGETIDS_FROM_NAMES */

#endif
