# open-apgen Documentation

This directory contains a few documents of interest:

  - [The Space Ops paper](./APGenSchedulingSpaceOps.pdf) retraces the evolution of APGen and its companion sequencing application, SEQGen, which was also developed at JPL and is used to simulate onboard execution of spacecraft sequences. Ideally, this paper should be supplemented by one discussing the same topic at a higher, big-picture level. See below for more about this.
  - [The DSL Design paper](./APGenDSLparser.pdf) explains the design of the APGen parser. It also describes in some detail the thinking behind the built-in APGen execution engine, which underwent significant refactoring when the Europa Clipper mission started using APGen to simulate the entire mission.
  - [The A++ powerpoint presentation](./Aplusplus.pdf) describes an attempt to answer the question "Could you avoid the DSL and write APGen adaptation in C++ instead?" The question has some merit, because most programmers are very fond of their favorite programming language(s). They feel that a DSL is too constraining and awkward for regular use. The presentation summarizes a 2-month attempt to reproduce some of the main features of the APGen DSL in C++. While the tone of the presentation is fairly positive and suggests that the answer to the question is "yes", the unanimous reaction from engineers who actually used the DSL was very negative because of their lack of familiarity with C++. In hindsight, the conclusion of the presentation should have been a resounding "no" answer to the question posed at the beginning. The DSL may be a poor substitute for existing general-purpose languages, but it does a very good job of encapsulating sophisticated constructs that are extremely helpful in writing bug-free simulation algorithms. Trying to create such constructs reliably with a general-purpose language is extremely difficult, because it takes enormous insight and discipline to define and then stick to patterns that work.

__Additional Notes about the Space Ops paper__

 This was not obvious at the beginning, but APGen's deep inheritance from SEQGen turned out to be an (unwitting) stroke of genius by the early APGen implementers at JPL, Rudy Valdez and Imin Lin. The reason why is pretty simple if one is familiar with the benefits of object-oriented design. What is it that makes object-oriented design a good thing? The answer is that looking for objects and their interactions in a programming task is an excellent way to tease out accurate requirements from a specification written by potential users. Once the "key players" and their responsibilities have been established, it is only natural to structure the software in a way that parallels them exactly. Thus, object-oriented design  shortens the logical path from requirements to implementation - a good thing by any measure. Likewise, the ultimate goal of a planning system for a space mission is to produce a command sequence that is safe for the spacecraft to execute and is guaranteed to achieve mission objectives. It is therefore natural to use the "objects" inherent in a command sequence as the primitives of the planning system.
  
But what are those objects? Onboard management and execution of spacecraft sequences are the responsibility of the so-called Command and Data Handling (C&DH) subsystem. While several paradigms have been used successfully to implement a C&DH, one that comes close to the experience of Earth-based programmers is the "cooperative multitasking" paradigm for an Operating System (OS). Modern OS's such as Linux and Mac OS use pre-emptive multitasking, but there was more variety in the early days of personal computers. In particular, the original Macintosh OS used a Pascal-based cooperative multitasking system. As it turns out, this is also the paradigm used by one of the successful C&DH implementations, [Virtual Machine Language (VML)](https://www.techbriefs.com/component/content/article/tb/pub/briefs/software/456). Not surprisingly, JPL's SEQGen validation program can be looked at as a high-fidelity, workstation-based model for the VML system embedded in a spacecraft's C&DH subsystem.

APGen treats the spacecraft model exactly like the C&DH subsystem treats the components of a real spacecraft: by sending them commands and querying sensors about their state. This architecture makes APGen and its DSL rather different from other simulation programs. An immense benefit of this architecture is that the transition from an APGen activity plan to a command sequence suitable for uplink to a spacecraft is an almost trivial step, thus making the transition from spacecraft design and implementation to mission operations completely seamless.

This choice of architecture also has unfortunate consequences. One of them is that programmers who are not familiar with C&DH requirements and design are reluctant to accept the resulting constraints on APGen's implementation details. For APGen to have any future at all, the organization responsible for its further development and evolution will need a crystal-clear view of its priorities in terms of overall mission capabilities and cost, as opposed to any individual preferences originating from its programming department.
